    1|       |//
    2|       |//  main.cpp
    3|       |//  assignment3
    4|       |//
    5|       |//  Created by Erik Poole on 1/15/19.
    6|       |//  Copyright Â© 2019 ErikPoole. All rights reserved.
    7|       |//
    8|       |
    9|       |#include <iostream>
   10|       |#include <sstream>
   11|       |#include <cmath>
   12|       |
   13|  6.39k|bool areEquivalent(double double1, double double2) {
   14|  6.39k|    return abs(double1 - double2) < .0001;
   15|  6.39k|}
   16|       |
   17|  3.98k|bool areEquivalent(double double1, double double2, double double3) {
   18|  3.98k|    return abs(double1 - double2) < .0001 && abs(double2 - double3) < .001;
   19|  3.98k|}
   20|       |
   21|       |//****************************************************************************************************
   22|       |//****************************************************************************************************
   23|       |
   24|       |
   25|       |class Point{
   26|       |private:
   27|       |    float x;
   28|       |    float y;
   29|       |    
   30|       |public:
   31|  27.9k|    Point() {
   32|  27.9k|    }
   33|       |    
   34|  3.99k|    Point(const float& xInput, const float& yInput) {
   35|  3.99k|        x = xInput;
   36|  3.99k|        y = yInput;
   37|  3.99k|    }
   38|       |    
   39|   121k|    float getX() const {return x;}
   40|  63.9k|    float getY() const {return y;}
   41|       |    
   42|  5.98k|    bool equals(Point inputPoint) {
   43|  5.98k|        if (x == inputPoint.getX()) {
   44|     74|            if (y == inputPoint.getY()) {
   45|      1|                return true;
   46|      1|            }
   47|  5.98k|        }
   48|  5.98k|        return false;
   49|  5.98k|    }
   50|       |};
   51|       |
   52|       |
   53|       |class Line{
   54|       |private:
   55|       |    int xOffset;
   56|       |    int yOffset;
   57|       |    Point pointArr[2];
   58|       |    
   59|       |public:
   60|  5.99k|    Line() {
   61|  5.99k|    }
   62|       |    
   63|  5.99k|    Line(const Point& point1, const Point& point2) {
   64|  5.99k|        pointArr[0] = point1;
   65|  5.99k|        pointArr[1] = point2;
   66|  5.99k|        xOffset = abs(point1.getX() - point2.getX());
   67|  5.99k|        yOffset = abs(point1.getY() - point2.getY());
   68|  5.99k|        
   69|  5.99k|    }
   70|       |    
   71|  3.19k|    double getLength() {
   72|  3.19k|        return sqrt((double) xOffset*xOffset + (double) yOffset*yOffset);
   73|  3.19k|    }
   74|       |    
   75|  26.5k|    double getSlope() {
   76|  26.5k|        //handles 0 slope without division
   77|  26.5k|        if (yOffset == 0) {
   78|    305|            return 0;
   79|    305|        }
   80|  26.2k|        //handles infinite slope without division
   81|  26.2k|        if(xOffset == 0) {
   82|    335|            return INT_MAX;
   83|    335|        }
   84|  25.9k|        
   85|  25.9k|        double slope = (double) yOffset / (double) xOffset;
   86|  25.9k|        if (pointArr[0].getX() > pointArr[1].getX() && pointArr[0].getY() < pointArr[1].getY()) {
   87|  3.00k|            slope *= -1;
   88|  3.00k|        }
   89|  25.9k|        if (pointArr[0].getX() < pointArr[1].getX() && pointArr[0].getY() > pointArr[1].getY()) {
   90|  2.83k|            slope *= -1;
   91|  2.83k|        }
   92|  25.9k|        return slope;
   93|  25.9k|    }
   94|       |};
   95|       |
   96|       |
   97|       |class Shape{
   98|       |private:
   99|       |    Point pointArr[4];
  100|       |    Line sideArr[4];
  101|       |    Line diagonalArr[2];
  102|       |    
  103|       |public:
  104|    999|    Shape(const Point& inputPoint1, const Point& inputPoint2, const Point& inputPoint3) {
  105|    999|        //points
  106|    999|        pointArr[0] = Point(0, 0);
  107|    999|        pointArr[1] = Point(inputPoint1);
  108|    999|        pointArr[2] = Point(inputPoint2);
  109|    999|        pointArr[3] = Point(inputPoint3);
  110|    999|        
  111|    999|        //sides
  112|    999|        sideArr[0] = Line(pointArr[0], pointArr[1]);
  113|    999|        sideArr[1] = Line(pointArr[1], pointArr[2]);
  114|    999|        sideArr[2] = Line(pointArr[2], pointArr[3]);
  115|    999|        sideArr[3] = Line(pointArr[3], pointArr[0]);
  116|    999|        
  117|    999|        //diagonals
  118|    999|        diagonalArr[0] = Line(pointArr[0], pointArr[2]);
  119|    999|        diagonalArr[1] = Line(pointArr[1], pointArr[3]);
  120|    999|        
  121|    999|    }
  122|       |    
  123|  12.7k|    Line getSide(const int& sideNumber) const {return sideArr[sideNumber];}
  124|      0|    Line getDiagonal(int diagonalNumber) const {return diagonalArr[diagonalNumber];}
  125|       |
  126|    999|    bool isValid() {
  127|    999|        //checks intersecting points
  128|  4.99k|        for (int i = 0; i < sizeof(pointArr)/sizeof(Point); i++) {
  129|  9.98k|            for (int j = i+1; j < sizeof(pointArr)/sizeof(Point); j++) {
  130|  5.98k|                if (pointArr[i].equals(pointArr[j])) {
  131|      1|                    std::cout << "error 2" << std::endl;
  132|      1|                    return false;
  133|      1|                }
  134|  5.98k|            }
  135|  3.99k|        }
  136|    999|        //checks 3 colinear points
  137|  4.98k|        for (int i = 0; i < sizeof(pointArr)/sizeof(Point); i++) {
  138|  3.98k|            int j = (i + 1) % 4;
  139|  3.98k|            int k = i % 2;
  140|  3.98k|            if (areEquivalent(sideArr[i].getSlope(), sideArr[j].getSlope(), diagonalArr[k].getSlope())) {
  141|      2|                std::cout << "error 4" << std::endl;
  142|      2|                return false;
  143|      2|            }
  144|  3.98k|        }
  145|    998|        
  146|    998|        //checks crossing points
  147|    998|        //checks clockwise:
  148|    998|        if (sideArr[3].getSlope() < sideArr[0].getSlope()) {
  149|    493|            if (sideArr[3].getSlope() > diagonalArr[0].getSlope()) {
  150|    171|                //if second line's slope is negative
  151|    171|                if (sideArr[1].getSlope() < 0) {
  152|    118|                    //if third line's slope is positive
  153|    118|                    if (sideArr[2].getSlope() > 0) {
  154|     63|                        std::cout << "error 3" << std::endl;
  155|     63|                        return false;
  156|     63|                    //if third line's slope is negative
  157|     63|                    } else if (sideArr[2].getSlope() < sideArr[1].getSlope()) {
  158|     34|                        std::cout << "error 3" << std::endl;
  159|     34|                        return false;
  160|     34|                    }
  161|     53|                //if second line's slope is positive
  162|     53|                } else {
  163|     53|                    if (diagonalArr[1].getSlope() > sideArr[1].getSlope()) {
  164|     23|                        std::cout << "error 3" << std::endl;
  165|     23|                        return false;
  166|     23|                    }
  167|    503|                }
  168|    171|            }
  169|    503|        //checks counter-clockwise:
  170|    503|        } else {
  171|    503|            if (sideArr[3].getSlope() < diagonalArr[0].getSlope()) {
  172|    176|                //if second line's slope is positive
  173|    176|                if (sideArr[1].getSlope() > 0) {
  174|     54|                    //if third line's slope is negative
  175|     54|                    if (sideArr[2].getSlope() < 0) {
  176|     13|                        std::cout << "error 3" << std::endl;
  177|     13|                        return false;
  178|     13|                        //if third line's slope is positive
  179|     41|                    } else if (sideArr[2].getSlope() > sideArr[1].getSlope()) {
  180|     28|                        std::cout << "error 3" << std::endl;
  181|     28|                        return false;
  182|     28|                    }
  183|    122|                    //if second line's slope is negative
  184|    122|                } else {
  185|    122|                    if (diagonalArr[1].getSlope() < sideArr[1].getSlope()) {
  186|     36|                        std::cout << "error 3" << std::endl;
  187|     36|                        return false;
  188|     36|                    }
  189|    799|                }
  190|    176|            }
  191|    503|        }
  192|    799|        return true;
  193|    799|    }
  194|       |
  195|       |};
  196|       |
  197|       |//****************************************************************************************************
  198|       |//****************************************************************************************************
  199|       |
  200|       |
  201|  3.19k|bool isParallelogram(const Shape& inputShape) {
  202|  3.19k|    if (areEquivalent(inputShape.getSide(0).getSlope(), inputShape.getSide(2).getSlope())) {
  203|      0|        if (areEquivalent(inputShape.getSide(1).getSlope(), inputShape.getSide(3).getSlope())) {
  204|      0|            return true;
  205|      0|        }
  206|  3.19k|    }
  207|  3.19k|    return false;
  208|  3.19k|}
  209|       |
  210|    799|bool isRectangle(const Shape& inputShape) {
  211|    799|    if (isParallelogram(inputShape)) {
  212|      0|        if (areEquivalent(inputShape.getDiagonal(0).getLength(), inputShape.getDiagonal(1).getLength())) {
  213|      0|            return true;
  214|      0|        }
  215|    799|    }
  216|    799|    return false;
  217|    799|}
  218|       |
  219|  1.59k|bool isRhombus(const Shape& inputShape) {
  220|  1.59k|    if (!isParallelogram(inputShape)) {
  221|  1.59k|        return false;
  222|  1.59k|    }
  223|      0|    for (int i = 0; i < 3; i++) {
  224|      0|        if (!areEquivalent(inputShape.getSide(i).getLength(), inputShape.getSide(i+1).getLength())) {
  225|      0|            return false;
  226|      0|        }
  227|      0|    }
  228|      0|    return true;
  229|      0|}
  230|       |
  231|    799|bool isSquare(const Shape& inputShape) {
  232|    799|    return isRhombus(inputShape) && isRectangle(inputShape);
  233|    799|}
  234|       |
  235|    799|bool isKite(const Shape& inputShape) {
  236|    799|    if (areEquivalent(inputShape.getSide(0).getLength(), inputShape.getSide(1).getLength())) {
  237|      0|        if (areEquivalent(inputShape.getSide(2).getLength(), inputShape.getSide(3).getLength())) {
  238|      0|            return true;
  239|      0|        }
  240|    799|    }
  241|    799|    if (areEquivalent(inputShape.getSide(1).getLength(), inputShape.getSide(2).getLength())) {
  242|      0|        if (areEquivalent(inputShape.getSide(3).getLength(), inputShape.getSide(0).getLength())) {
  243|      0|            return true;
  244|      0|        }
  245|    799|    }
  246|    799|    return false;
  247|    799|}
  248|       |
  249|    799|bool isTrapezoid(const Shape& inputShape) {
  250|    799|    if (areEquivalent(inputShape.getSide(0).getSlope(), inputShape.getSide(2).getSlope())) {
  251|      0|        if (!areEquivalent(inputShape.getSide(1).getSlope(), inputShape.getSide(3).getSlope())) {
  252|      0|            return true;
  253|      0|        }
  254|    799|    }
  255|    799|    if (areEquivalent(inputShape.getSide(1).getSlope(), inputShape.getSide(3).getSlope())) {
  256|      1|        if (!areEquivalent(inputShape.getSide(0).getSlope(), inputShape.getSide(2).getSlope())) {
  257|      1|            return true;
  258|      1|        }
  259|    798|    }
  260|    798|    return false;
  261|    798|}
  262|       |
  263|       |//****************************************************************************************************
  264|       |//****************************************************************************************************
  265|       |
  266|    999|bool isValidInput(std::string inputString) {
  267|    999|    if (!std::isdigit(inputString[0])) {
  268|      0|        return false;
  269|      0|    }
  270|    999|    int numberCount = 1;
  271|    999|    int spaceCount = 0;
  272|    999|    int valueCount = 1;
  273|  15.4k|    for (int i = 1; i < inputString.length()-1; i++) {
  274|  14.4k|        if (std::isdigit(inputString[i])) {
  275|  9.44k|            numberCount++;
  276|  9.44k|            spaceCount = 0;
  277|  9.44k|        } else if (inputString[i] == ' ') {
  278|  4.99k|            numberCount = 0;
  279|  4.99k|            spaceCount++;
  280|  4.99k|            valueCount++;
  281|  4.99k|        } else {
  282|      0|            return false;
  283|      0|        }
  284|  14.4k|        
  285|  14.4k|        if (numberCount > 3 || spaceCount > 1) {
  286|      0|            return false;
  287|      0|        }
  288|  14.4k|    }
  289|    999|    if (valueCount != 6) {
  290|      0|        return false;
  291|      0|    }
  292|    999|    
  293|    999|    return true;
  294|    999|}
  295|       |
  296|       |//****************************************************************************************************
  297|       |//****************************************************************************************************
  298|       |
  299|       |
  300|  1.00k|int main(int argc, const char * argv[]) {
  301|  1.00k|//    std::cout << "poop" << std::endl;
  302|  1.00k|    std::string inputString;
  303|  1.79k|    while(std::getline(std::cin, inputString)) {
  304|    999|        if (!isValidInput(inputString)) {
  305|      0|            std::cout << "error 1" << std::endl;
  306|      0|            return 0;
  307|      0|        }
  308|    999|        
  309|    999|        std::stringstream stringStream(inputString);
  310|    999|        std::string singleInput;
  311|    999|        int inputValueArray[6];
  312|    999|        int *inputValuePointer = inputValueArray;
  313|  6.99k|        while (std::getline(stringStream, singleInput, ' ')){
  314|  5.99k|            *inputValuePointer++ = std::stoi(singleInput);
  315|  5.99k|        }
  316|    999|        
  317|  5.99k|        for (int value : inputValueArray) {
  318|  5.99k|            if (value > 100) {
  319|      0|                std::cout << "error 1" << std::endl;
  320|      0|                return 0;
  321|      0|            }
  322|  5.99k|        }
  323|    999|        
  324|    999|        Point point1(inputValueArray[0], inputValueArray[1]);
  325|    999|        Point point2(inputValueArray[2], inputValueArray[3]);
  326|    999|        Point point3(inputValueArray[4], inputValueArray[5]);
  327|    999|        Shape shape(point1, point2, point3);
  328|    999|        
  329|    999|        if (!shape.isValid()) {
  330|    200|            return 0;
  331|    200|        }
  332|    799|        
  333|    799|        std::string outputString;
  334|    799|        if (isSquare(shape)) {
  335|      0|            outputString = "square";
  336|    799|        } else if (isRhombus(shape)) {
  337|      0|            outputString = "rhombus";
  338|    799|        } else if (isRectangle(shape)) {
  339|      0|            outputString = "rectangle";
  340|    799|        } else if (isParallelogram(shape)) {
  341|      0|            outputString = "parallelogram";
  342|    799|        } else if (isKite(shape)) {
  343|      0|            outputString = "kite";
  344|    799|        } else if (isTrapezoid(shape)) {
  345|      1|            outputString = "trapezoid";
  346|    798|        } else {
  347|    798|            outputString = "quadrilateral";
  348|    798|        }
  349|    799|        std::cout << outputString << std::endl;
  350|    799|    }
  351|  1.00k|}

